package main

import (
	"flag"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"strconv"

	cfg "github.com/chryscloud/go-microkit-plugins/config"
	msrv "github.com/chryscloud/go-microkit-plugins/server"
	"github.com/mailio/mailio-nft-server/config"
	"github.com/mailio/mailio-nft-server/docs"
	"github.com/mailio/mailio-nft-server/router"
	// docs is generated by Swag CLI, you have to import it.
)

// @title           Mailio NFT Server API
// @version         1.0
// @description     Mailio NFT Swagger Document
// @termsOfService  https://mail.io/tos

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @securityDefinitions.apikey  ApiKeyAuth
// @in                          header
// @name                        Authorization

func main() {
	var (
		configFile string
	)
	// configuration file optional path. Default:  current dir with  filename conf.yaml
	flag.StringVar(&configFile, "c", "conf.yaml", "Configuration file path.")
	flag.StringVar(&configFile, "config", "conf.yaml", "Configuration file path.")
	flag.Usage = usage
	flag.Parse()

	// init configuration from conf.yaml
	err := cfg.NewYamlConfig(configFile, &config.Conf)
	if err != nil {
		config.Log.Error(err, "conf.yaml failed to load")
		panic("Failed to load conf.yaml")
	}

	// server wait to shutdown monitoring channels
	done := make(chan bool, 1)
	quit := make(chan os.Signal, 1)

	signal.Notify(quit, os.Interrupt)

	// programmatically set swagger info
	docs.SwaggerInfo.Title = "Mailio NFT API"
	docs.SwaggerInfo.Description = "Mailio NFT API"
	docs.SwaggerInfo.Version = config.Conf.Version
	docs.SwaggerInfo.Host = "localhost:" + strconv.Itoa(config.Conf.Port)
	docs.SwaggerInfo.BasePath = "/api"
	docs.SwaggerInfo.Schemes = []string{"http"}

	env := setupEnvironment(&config.Conf)
	defer tearDownEnvironment(env)

	// init routing (for endpoints)
	apiRouter := msrv.NewAPIRouter(&config.Conf.YamlConfig)
	r := router.ConfigAPI(apiRouter, env, &config.Conf)

	// start server
	srv := msrv.Start(&config.Conf.YamlConfig, r, config.Log)
	// wait for server shutdown
	go msrv.Shutdown(srv, config.Log, quit, done)

	config.Log.Info("Server is ready to handle requests at", config.Conf.Port)
	if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		config.Log.Error("Could not listen on %s: %v\n", config.Conf.Port, err)
	}

	<-done
}

// usage will print out the flag options for the server.
func usage() {
	usageStr := `Usage: operator [options]
	Server Options:
	-c, --config <file>              Configuration file path
`
	fmt.Printf("%s\n", usageStr)
	os.Exit(0)
}
